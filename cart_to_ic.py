import math
import numpy as np
from numpy.linalg import norm

#O H O H ordering

m = np.array([
                [ -0.068083601491  ,   0.905122939168  ,   0.000000000000],
                [  1.007592596562  ,   1.007990924339  ,   0.000000000000],   
                [  0.052994706553  ,  -0.906571657350  ,   0.000000000000],    
                [ -0.768120884189  ,  -0.984998715486  ,   0.000000000000]     
        ])


def conv(m):
    r1 = (((m[0][0] - m[1][0])**2) + ((m[0][1] - m[1][1])**2) + ((m[0][2] - m[1][2])**2))**(0.5)  #OH length
    r2 = (((m[0][0] - m[2][0])**2) + ((m[0][1] - m[2][1])**2) + ((m[0][2] - m[2][2])**2))**(0.5)  #OO length
    r3 = (((m[2][0] - m[3][0])**2) + ((m[2][1] - m[3][1])**2) + ((m[2][2] - m[3][2])**2))**(0.5)  #O'H' length
    rc1 = (((m[1][0] - m[2][0])**2) + ((m[1][1] - m[2][1])**2) + ((m[1][2] - m[2][2])**2))**(0.5) #HO'
    rc2 = (((m[0][0] - m[3][0])**2) + ((m[0][1] - m[3][1])**2) + ((m[0][2] - m[3][2])**2))**(0.5) #OH'
    a1 = math.acos(((rc1**2) - (r1**2) - (r2**2)) / (-2 * r1 *r2)) * (180 / math.pi)
    a2 = math.acos(((rc2**2) - (r3**2) - (r2**2)) / (-2 * r3 *r2)) * (180 / math.pi)
    #n1 = np.cross([m[0][0]-m[1][0], m[0][1]-m[1][1], m[0][2]-m[1][2]], [m[0][0]-m[2][0], m[0][1]-m[2][1], m[0][2]-m[2][2]])
    #n2 = np.cross([m[2][0]-m[0][0], m[2][1]-m[0][1], m[2][2]-m[0][2]], [m[2][0]-m[3][0], m[2][1]-m[3][1], m[2][2]-m[3][2]])
    #d1 = math.acos(np.dot(n1/norm(n1),n2/norm(n2))) * (180/math.pi)
    return r2, r1, r3, a1, a2

print(conv(m))
